% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/spxlvb.R
\name{spxlvb}
\alias{spxlvb}
\title{Parameter Exploded Variational Bayes for Well-Calibrated High-Dimensional Linear Regression with Spike-and-Slab Priors}
\usage{
spxlvb(
  X,
  Y,
  mu_0 = NULL,
  omega_0 = NULL,
  c_pi_0 = NULL,
  d_pi_0 = NULL,
  tau_e = NULL,
  update_order = NULL,
  initialization = c("lasso", "ridge", "lasso_ridge", "null"),
  mu_alpha = rep(1, ncol(X) + 1),
  alpha_prior_precision = 1000,
  b_prior_precision = rep(1, ncol(X)),
  standardize = TRUE,
  intercept = TRUE,
  max_iter = 1000,
  tol = 0.001,
  save_history = TRUE,
  convergence = c("elbo_relative", "elbo_absolute", "chisq", "entropy"),
  update_pi = FALSE,
  include_exploded_elbo_constants = FALSE,
  disable_global_alpha = FALSE,
  track_coordinate_exploded_elbo = FALSE,
  track_all_criteria = FALSE,
  gamma_hyperprior_tau_alpha = FALSE,
  r_alpha = NULL,
  d_alpha = NULL,
  gamma_hyperprior_tau_b = FALSE,
  r_b = NULL,
  d_b = NULL,
  seed = 12376
)
}
\arguments{
\item{X}{A numeric matrix. The design matrix (n observations Ã— p predictors).}

\item{Y}{A numeric vector. The response vector of length n.}

\item{mu_0}{Optional numeric vector. Initial variational means for regression coefficients.}

\item{omega_0}{Optional numeric vector. Initial spike probabilities.}

\item{c_pi_0}{Optional numeric. Prior Beta(a, b) parameter a for the spike probability.}

\item{d_pi_0}{Optional numeric. Prior Beta(a, b) parameter b for the spike probability.}

\item{tau_e}{Optional numeric. Known or estimated error precision.}

\item{update_order}{Optional integer vector. The coordinate update order (0-indexed for C++).}

\item{initialization}{Character string specifying the initialization
strategy. One of \code{"lasso"} (default), \code{"ridge"},
\code{"lasso_ridge"}, or \code{"null"}. See
\code{\link{get_initials_spxlvb}} for details. Pre-supplied values
(\code{mu_0}, \code{omega_0}, etc.) always override the strategy.}

\item{mu_alpha}{Numeric vector of length \eqn{p+1}. Prior means for the
explosion parameters \eqn{\alpha_1,\ldots,\alpha_{p+1}}.
Elements 1 to \eqn{p} are the per-coordinate explosion prior means;
element \eqn{p+1} is the prior mean for the global explosion
parameter \eqn{\alpha_{p+1}} (applied after each full coordinate sweep).
The \eqn{p+1} dimension comes from the global explosion parameter,
not from an intercept term.
Defaults to a vector of ones of length \eqn{p+1} (determined
automatically from \code{X}), centering all explosion parameters
at 1 (no rescaling a priori).}

\item{alpha_prior_precision}{Numeric scalar. Shared prior precision
\eqn{\tau_\alpha} for all \eqn{p+1} explosion parameters.
Each \eqn{\alpha_j \sim N(\mu_{\alpha,j},\;
  (\tau_\epsilon \tau_\alpha)^{-1})}. Larger values shrink the
explosion parameters toward their prior means (closer to standard VB).
Default is 1000.}

\item{b_prior_precision}{Numeric vector of length \eqn{p}.
Coordinate-specific slab prior precisions
\eqn{\tau_{b,1},\ldots,\tau_{b,p}}. Each slab component has
\eqn{b_j \mid s_j=1 \sim N(0,\; (\tau_\epsilon \tau_{b,j})^{-1})}.
These are the slab precisions for the regression coefficients,
not for the explosion parameters.
Defaults to a vector of ones of length \eqn{p} (determined
automatically from \code{X}).}

\item{standardize}{Logical. Center Y, and center and scale X. Default is TRUE.}

\item{intercept}{Logical. Whether to include an intercept. Default is TRUE. After the model is fit on the centered and scaled data, the final coefficients are "unscaled" to put them back on the original scale of your data. The intercept is then calculated separately using the means and the final coefficients.}

\item{max_iter}{Maximum number of iterations for the variational update. Default is 1000.}

\item{tol}{Convergence threshold for entropy and alpha change. Default is 1e-5.}

\item{save_history}{Logical. If TRUE (default), per-iteration parameter histories are stored and returned. Set to FALSE to save memory in large-scale simulations.}

\item{convergence}{Character string specifying the convergence criterion.
One of \code{"elbo_relative"} (default), \code{"elbo_absolute"},
\code{"chisq"}, or \code{"entropy"}.
\code{"elbo_relative"} stops when the relative change in the exploded
ELBO, \eqn{|\Delta \mathrm{ELBO}| / (|\mathrm{ELBO}| + 10^{-10})},
falls below \code{tol}.
\code{"elbo_absolute"} stops when the absolute change in the exploded
ELBO, \eqn{|\Delta \mathrm{ELBO}|}, falls below \code{tol}.
\code{"chisq"} uses a chi-squared test on normalised changes in the
linear predictor.
\code{"entropy"} stops when the maximum absolute change in
per-coordinate Bernoulli entropy of the inclusion probabilities
falls below \code{tol}, following the criterion used by
Ray and Szabo (2022).
See Appendix for a comparison of the four criteria.}

\item{update_pi}{Logical. If \code{TRUE}, treat \eqn{\pi} as a variational
parameter with \eqn{q(\pi) = \text{Beta}(\tilde{c}_\pi, \tilde{d}_\pi)},
updated each iteration via the conjugate Beta--Bernoulli update.
If \code{FALSE} (default), \eqn{\pi} is fixed at
\eqn{c_\pi / (c_\pi + d_\pi)}.}

\item{include_exploded_elbo_constants}{Logical. If \code{TRUE}, include all
normalizing constants in the exploded ELBO (likelihood normalization,
\eqn{2\pi} factors, Gaussian entropy constants). These terms are
independent of variational parameters and tuned hyperparameters, so they
cannot affect hyperparameter selection. However, they shift the absolute
ELBO level, which can affect the relative-change convergence criterion.
Default: \code{FALSE}.}

\item{disable_global_alpha}{Logical. If \code{TRUE}, skip the global
\eqn{\alpha_{p+1}} rescaling step after each full coordinate sweep.
Per-coordinate \eqn{\alpha_j} rescaling still occurs. This reduces
the parameter explosion to coordinate-level only and is used for
ablation studies (see the paper Appendix, Section C.2.1).
Default: \code{FALSE}.}

\item{track_coordinate_exploded_elbo}{Logical. If \code{TRUE}, compute the
exploded ELBO (data fit, slab normalisation, slab penalty, alpha
normalisation, alpha penalty, pi logodds, slab entropy, spike entropy)
and the \eqn{\alpha}-stripped ELBO (exploded ELBO minus alpha terms)
after each individual coordinate update within the inner loop and check
both for monotonicity violations.
Returns \code{coordinate_exploded_elbo_violations} and
\code{coordinate_exploded_elbo_worst_drop} for the exploded ELBO,
plus \code{coordinate_alpha_stripped_elbo_violations} and
\code{coordinate_alpha_stripped_elbo_worst_drop} for the
\eqn{\alpha}-stripped ELBO.
Intended for diagnostic use only as it adds
\eqn{O(p^2 + np)} work per outer iteration.
Default: \code{FALSE}.}

\item{track_all_criteria}{Logical. If \code{TRUE}, compute and store
per-iteration values of all four convergence criteria (ELBO,
chi-squared p-value, and maximum entropy change) regardless of which
criterion is used for stopping.  This enables post-hoc extraction of
the iteration at which any criterion would have triggered convergence
at any tolerance, without rerunning the algorithm.  Requires
materialising the \eqn{n \times p} element-wise squared design matrix
and adds \eqn{O(np)} work per iteration for the chi-squared statistic.
Returns \code{chisq_history} and \code{entropy_change_history} in
addition to the always-returned \code{elbo_history} and
\code{alpha_stripped_elbo_history}.
Default: \code{FALSE}.}

\item{gamma_hyperprior_tau_alpha}{Logical. If \code{TRUE}, place a conjugate
\eqn{\text{Gamma}(r_\alpha, d_\alpha)} hyperprior on
\eqn{\tau_\alpha} and update it within the VB loop. The variational
update is \eqn{q(\tau_\alpha) = \text{Gamma}(r_{\text{post}},
  d_{\text{post}})} with \eqn{r_{\text{post}} = r_\alpha + (p+1)/2}
and \eqn{d_{\text{post}} = d_\alpha + (\tau_\epsilon / 2)
  \sum_k E_q[(\alpha_k - \mu_{\alpha,k})^2]}. The posterior mean
\eqn{E[\tau_\alpha] = r_{\text{post}} / d_{\text{post}}} replaces
the fixed \code{alpha_prior_precision / tau_e} at each iteration.
This eliminates the need to grid-search over \eqn{\tau_\alpha},
reducing tuning to a 1D search over \eqn{\tau_b} only.
The hyperprior parameters \code{r_alpha} and \code{d_alpha} are not
sensitive: with \eqn{(p+1)/2} effective observations from the alpha
posteriors, even a vague prior is quickly overwhelmed by the data.
Default: \code{FALSE}.}

\item{r_alpha}{Numeric scalar. Shape parameter for the Gamma hyperprior
on \eqn{\tau_\alpha}. Only used when \code{gamma_hyperprior_tau_alpha = TRUE}.
Default: \code{alpha_prior_precision / tau_e} (matches the initial
\eqn{\tau_\alpha} from the fixed-precision parameterisation when
\code{d_alpha = 1}).}

\item{d_alpha}{Numeric scalar. Rate parameter for the Gamma hyperprior
on \eqn{\tau_\alpha}. Only used when \code{gamma_hyperprior_tau_alpha = TRUE}.
Default: 1.}

\item{gamma_hyperprior_tau_b}{Logical. If \code{TRUE}, place a conjugate
\eqn{\text{Gamma}(r_b, d_b)} hyperprior on the shared slab precision
\eqn{\tau_b} and update it within the VB loop.  At each iteration,
\eqn{E[\tau_b] = r_{b,\text{post}} / d_{b,\text{post}}} is computed
and all per-coordinate \eqn{\tau_{b,j}} are reset to this common
value.  Combined with \code{gamma_hyperprior_tau_alpha = TRUE}, this makes the
algorithm fully tuning-free (no grid search needed).
Default: \code{FALSE}.}

\item{r_b}{Numeric scalar. Shape parameter for the Gamma hyperprior
on \eqn{\tau_b}. Only used when \code{gamma_hyperprior_tau_b = TRUE}.
Default: \code{b_prior_precision[1] / tau_e} (matches initial
\eqn{\tau_b}).}

\item{d_b}{Numeric scalar. Rate parameter for the Gamma hyperprior
on \eqn{\tau_b}. Only used when \code{gamma_hyperprior_tau_b = TRUE}.
Default: 1.}

\item{seed}{Integer seed for cross-validation in glmnet. Default is 12376.}
}
\value{
A list with posterior summaries including estimated coefficients (\code{mu}),
inclusion probabilities (\code{omega}), intercept (if applicable), alpha path, convergence status, etc.
}
\description{
Fits a sparse linear regression model using variational inference with parameter explosion.
The model uses spike-and-slab priors.
}
\details{
\strong{Parameter explosion.}
The algorithm introduces \eqn{p+1} explosion parameters
\eqn{\alpha_1,\ldots,\alpha_p,\alpha_{p+1}}. The \eqn{+1} comes
from the global explosion parameter \eqn{\alpha_{p+1}}, not from an
intercept. At each coordinate update \eqn{j}, the optimal
\eqn{\alpha_j} rescales all other variational parameters to improve
calibration. After a full sweep through all \eqn{p} coordinates, a
global \eqn{\alpha_{p+1}} rescaling is applied. When all explosion
parameters equal 1,
the algorithm reduces to standard coordinate-ascent VB.

The key user-facing parameters governing the explosion are
\code{mu_alpha} (length \eqn{p+1}) and \code{alpha_prior_precision}
(scalar, shared). The slab prior precisions \code{b_prior_precision}
(length \eqn{p}) are separate and control the spike-and-slab
component, not the explosion.

\strong{Intercept handling.}
When \code{intercept = TRUE} (requires \code{standardize = TRUE}),
the model is fit on centered-and-scaled data (no intercept column is
added to \code{X}). After convergence, the coefficients are unscaled
to the original data scale, and the intercept is computed as
\eqn{\hat\beta_0 = \bar Y - \sum_{j=1}^{p} \hat\beta_j \bar X_j},
where \eqn{\bar Y} and \eqn{\bar X_j} are the original sample means.
The returned \code{beta} vector has length \eqn{p+1} (intercept
first), but this \eqn{+1} is unrelated to the explosion parameter
dimension.
}
\examples{
\donttest{
set.seed(1)
n <- 50; p <- 20
X <- matrix(rnorm(n * p), n, p)
Y <- X[, 1:3] \%*\% c(1, -1, 0.5) + rnorm(n)
fit <- spxlvb(X = X, Y = Y, max_iter = 50)
}
}
