% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cv.spxlvb.R
\name{cv.spxlvb}
\alias{cv.spxlvb}
\title{Cross-validation for Sparse Parameter Exploded Variational Bayes (spxlvb)}
\usage{
cv.spxlvb(
  k = 5,
  X,
  Y,
  mu_0 = NULL,
  omega_0 = NULL,
  c_pi_0 = NULL,
  d_pi_0 = NULL,
  tau_e = NULL,
  update_order = NULL,
  mu_alpha = NULL,
  alpha_prior_precision_grid = c(0, 10^(3:7)),
  b_prior_precision_grid = NULL,
  b_prior_precision = rep(1, ncol(X)),
  standardize = TRUE,
  intercept = TRUE,
  max_iter = 100L,
  tol = 1e-05,
  seed = 12376,
  verbose = TRUE,
  parallel = TRUE
)
}
\arguments{
\item{k}{Integer, the number of folds for cross-validation. Must be at least 3.}

\item{X}{A numeric design matrix of dimension \eqn{n \times p}.}

\item{Y}{A numeric response vector of length \eqn{n}.}

\item{mu_0}{Optional numeric vector of length \eqn{p}. Initial variational means.}

\item{omega_0}{Optional numeric vector of length \eqn{p}. Initial variational probabilities.}

\item{c_pi_0}{Optional numeric. Prior shape1 parameter for \eqn{\pi}.}

\item{d_pi_0}{Optional numeric. Prior shape2 parameter for \eqn{\pi}.}

\item{tau_e}{Optional numeric. Initial precision of errors.}

\item{update_order}{Optional integer vector specifying the coordinate update sequence (0-indexed for C++).}

\item{mu_alpha}{Optional numeric vector of length \eqn{p+1}. Prior means for the expansion parameters.}

\item{alpha_prior_precision_grid}{A numeric vector of values to cross-validate over.
Defaults to \code{c(0, 10^(3:7))}.}

\item{b_prior_precision_grid}{Optional numeric vector of scalar slab prior
precisions to cross-validate over. When \code{NULL} (default), the scalar
\code{b_prior_precision} is used for every fit (1D search over
\code{alpha_prior_precision} only). When non-\code{NULL}, a 2D grid
search is performed over all combinations of
\code{alpha_prior_precision_grid} and \code{b_prior_precision_grid}.
Each grid value is expanded to a constant vector of length \eqn{p}.}

\item{b_prior_precision}{Numeric vector of length \eqn{p}.
Coordinate-specific slab prior precisions
(see \code{\link{spxlvb}} for details). Used only when
\code{b_prior_precision_grid} is \code{NULL}.
Defaults to a vector of ones of length \eqn{p} (determined
automatically from \code{X}).}

\item{standardize}{Logical. Should the design matrix be standardized? Defaults to TRUE.}

\item{intercept}{Logical. Should an intercept be included in the model? Defaults to TRUE.}

\item{max_iter}{Integer. Maximum number of iterations for each model fit.}

\item{tol}{Numeric. Convergence tolerance for the Variational Bayes algorithm.}

\item{seed}{Integer. Seed for reproducibility of data splitting.}

\item{verbose}{Logical. If TRUE, progress messages are printed to the console.}

\item{parallel}{Logical. If TRUE, execution is performed in parallel using the
currently registered backend (e.g., via \code{doParallel}).}
}
\value{
A list containing:
\item{ordered_alpha_prior_precision_grid}{The sorted alpha hyperparameter grid.}
\item{ordered_b_prior_precision_grid}{The sorted b hyperparameter grid
(only present when \code{b_prior_precision_grid} is non-\code{NULL}).}
\item{epe_test_k}{Prediction errors per fold. A matrix (folds x alpha grid)
for 1D search, or a 3D array (folds x alpha grid x b grid) for 2D search.}
\item{CVE}{Mean CVE. A named vector for 1D search, or a matrix
(alpha grid x b grid) for 2D search.}
\item{alpha_prior_precision_grid_opt}{Optimal alpha value.}
\item{b_prior_precision_grid_opt}{Optimal b value
(only present when \code{b_prior_precision_grid} is non-\code{NULL}).}
}
\description{
Performs k-fold cross-validation for the \code{spxlvb} model to
optimize hyperparameters. By default, only
\code{alpha_prior_precision} is searched (1D CV). When
\code{b_prior_precision_grid} is supplied, a joint 2D search over both
\code{alpha_prior_precision} and \code{b_prior_precision} is performed.
}
\details{
To use parallel processing, a backend must be registered before calling
this function. For example: \code{doParallel::registerDoParallel(cores = 4)}.
}
\examples{
\donttest{
set.seed(1)
n <- 50; p <- 20
X <- matrix(rnorm(n * p), n, p)
Y <- X[, 1:3] \%*\% c(1, -1, 0.5) + rnorm(n)
result <- cv.spxlvb(k = 3, X = X, Y = Y,
  alpha_prior_precision_grid = c(100, 1000), parallel = FALSE)
}
}
