% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/grid.search.spxlvb.fit.R
\name{grid.search.spxlvb.fit}
\alias{grid.search.spxlvb.fit}
\title{Grid search and Final Model Fitting for spxlvb}
\usage{
grid.search.spxlvb.fit(
  X,
  Y,
  X_validation = NULL,
  Y_validation = NULL,
  beta_true = NULL,
  mu_0 = NULL,
  omega_0 = NULL,
  c_pi_0 = NULL,
  d_pi_0 = NULL,
  tau_e = NULL,
  update_order = NULL,
  mu_alpha = rep(1, ncol(X) + 1),
  alpha_prior_precision_grid = c(10, 50, 100, 400, 1000),
  b_prior_precision_grid = seq(0.001, 5, length.out = 5),
  standardize = TRUE,
  intercept = TRUE,
  max_iter = 100L,
  tol = 1e-05,
  seed = 12376,
  verbose = TRUE,
  parallel = TRUE
)
}
\arguments{
\item{X}{A design matrix (training).}

\item{Y}{A response vector (training).}

\item{X_validation}{Optional design matrix for the validation set.}

\item{Y_validation}{Optional response vector for the validation set.}

\item{beta_true}{Optional vector of true coefficients (length p or p+1).}

\item{mu_0}{Initial variational mean.}

\item{omega_0}{Initial variational probability.}

\item{c_pi_0}{Prior parameter for pi (shape1).}

\item{d_pi_0}{Prior parameter for pi (shape2).}

\item{tau_e}{Initial precision of errors.}

\item{update_order}{Numeric vector for update order.}

\item{mu_alpha}{Numeric vector of length \eqn{p+1}. Prior means for
the expansion parameters. The \eqn{p+1} dimension comes from the
global expansion parameter, not an intercept
(see \code{\link{spxlvb}} for details).
Defaults to a vector of ones of length \eqn{p+1} (determined
automatically from \code{X}).}

\item{alpha_prior_precision_grid}{Numeric vector. Grid of expansion prior
precision values to search over.}

\item{b_prior_precision_grid}{Numeric vector. Grid of scalar slab prior
precisions to search over. Each scalar value is internally expanded
to a constant vector of length \eqn{p} via
\code{rep(value, ncol(X))}.}

\item{standardize}{Logical. Default is TRUE.}

\item{intercept}{Logical. Default is TRUE.}

\item{max_iter}{Maximum iterations.}

\item{tol}{Convergence tolerance.}

\item{seed}{Seed for reproducibility.}

\item{verbose}{Logical, if TRUE, prints progress.}

\item{parallel}{Logical, if TRUE, search in parallel.}
}
\value{
A list with elements \code{hyper_grid} (data frame of all grid
combinations and their metrics), \code{optimal_hyper} (the selected
hyperparameter values), \code{fit_spxlvb} (the final fitted model),
\code{selection_criterion} (the criterion used), and
\code{refitted_on_combined} (logical).
}
\description{
This function performs grid search to determine optimal hyperparameters.
Optimality is determined by: 1. mse_validation_Xbeta (if available), 2. mse_validation_y (if available), 3. elbo.
}
\examples{
\donttest{
set.seed(1)
n <- 50; p <- 20
X <- matrix(rnorm(n * p), n, p)
Y <- X[, 1:3] \%*\% c(1, -1, 0.5) + rnorm(n)
result <- grid.search.spxlvb.fit(X = X, Y = Y,
  alpha_prior_precision_grid = c(100, 1000),
  b_prior_precision_grid = c(1, 5),
  parallel = FALSE)
}
}
